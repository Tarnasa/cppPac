"""
Creates a plot given fitness data
"""

# Built-ins
import argparse
import re
import itertools

# Third party
import matplotlib.pyplot

parser = argparse.ArgumentParser(description='Generates plots from log files generated by cppPac.exe')

parser.add_argument('--score', '-l', dest='log', type=argparse.FileType('r'), required=True,
                    help='The name of the score log file used to generate the plot.')
parser.add_argument('--out', '-o', dest='out', default=None, required=False,
                    help='The name of the generated plot file (Can be .png or .pdf).  '
                    'Defaults to just showing the plot.')
parser.add_argument('--x-axis', '-x', dest='x_axis', default='Evaluations', required=False,
                    help='The label for the horizontal axis')
parser.add_argument('--y-axis', '-y', dest='y_axis', default='Fitness', required=False,
                    help='The label for the vertical axis')
parser.add_argument('--title', '-t', dest='title', default=None, type=str, required=False,
                    help='The title to display at the top of the plot.  FILENAME is replaced by input filename.  '
                    'HORIZONTAL is replaced by horizontal axis label.  VERTICAL is replaced by vertical axis label.'
                    'Defaults to the name of the input file.')
parser.add_argument('--datasets', '-d', dest='labels', default='', required=False,
                    help='A comma-delimited list of labels for use in a legend if multiple datasets are used')

args = parser.parse_args()

if not args.title:
    args.title = 'VERTICAL vs. HORIZONTAL for FILENAME'
args.title = args.title.replace('HORIZONTAL', args.x_axis)
args.title = args.title.replace('VERTICAL', args.y_axis)
args.title = args.title.replace('FILENAME', args.log.name)

# Separate runs
runs = re.split(r'\r?\nRun [0-9]+\r?\n', args.log.read())

# Find info from log header
max_evaluations = int(re.search('eval[^:\n]+: ([0-9]+)', runs[0], flags=re.IGNORECASE).group(1))

# Prepare data
evals_values = list()
average_values = list()
best_values = list()
for run_index, run in enumerate(runs[1:]):
    for line_index, line in enumerate(itertools.ifilter(None, re.split(r'\r?\n', run))):
        evals, average, best = re.match(r'([0-9]+)\t([0-9.]+)\t([0-9.]+)', line).groups()
        evals = int(evals)
        average = float(average)
        best = float(best)
        if run_index == 0:
            evals_values.append(evals)
            average_values.append((list()))
            best_values.append(list())
        average_values[line_index].append(average)
        best_values[line_index].append(best)


def plot_two_box_and_average(averages, bests, average_color, best_color, average_line_format, best_line_format):
    figure = matplotlib.pyplot.figure()
    big = figure.add_subplot(1, 1, 1)

    box_step_size = len(average_values) / 10
    box_width = evals_values[-1] / 17.0

    def box_and_average_plot(values, color, line_format, label):
        # Plot box plot
        box = big.boxplot([x for x in values[::box_step_size]], positions=evals_values[::box_step_size],
                          labels=[[str(x), ''][i % 2] for i, x in enumerate(evals_values[::box_step_size])],
                          widths=box_width)
        matplotlib.pyplot.setp(box['boxes'], color=color)
        matplotlib.pyplot.setp(box['whiskers'], color=color)
        matplotlib.pyplot.setp(box['medians'], color=color)
        matplotlib.pyplot.setp(box['fliers'], color=color)

        # Plot average of values line
        return big.plot(evals_values, [sum(a) / float(len(a)) for a in values], line_format, label=label)

    labels = args.labels.split(',') + [''] * (2 - len(args.labels.split(',')))
    average_line, = box_and_average_plot(averages, average_color, average_line_format, labels[0])
    best_line, = box_and_average_plot(bests, best_color, best_line_format, labels[1])

    # Setup dimensions
    big.set_xlim(0, evals_values[-1] * 1.05)
    big.set_ylim(min(min(x for x in column) for column in averages) * 0.95,
                 max(max(x for x in column) for column in bests) * 1.05)

    matplotlib.pyplot.title(args.title)
    matplotlib.pyplot.xlabel(args.x_axis)
    matplotlib.pyplot.ylabel(args.y_axis)

    if args.labels and len(args.labels.split(',')) == 2:
        big.legend(handles=[average_line, best_line], labels=args.labels.split(','), loc='upper left')

    if args.out:
        figure.savefig(args.out)
    else:
        matplotlib.pyplot.show()


def plot_separate_runs(values, line_format):
    figure = matplotlib.pyplot.figure()
    big = figure.add_subplot(1, 1, 1)

    for r in range(len(runs) - 1):
        big.plot(evals_values, [x[r] for x in values], line_format)

    # Setup dimensions
    big.set_xlim(0, evals_values[-1] * 1.05)
    big.set_ylim(min(min(x for x in column) for column in values) * 0.95,
                 max(max(x for x in column) for column in values) * 1.05)

    matplotlib.pyplot.title(args.title)
    matplotlib.pyplot.xlabel(args.x_axis)
    matplotlib.pyplot.ylabel(args.y_axis)

    if args.out:
        out_name = args.out
        figure.savefig(out_name)
    else:
        matplotlib.pyplot.show()

plot_two_box_and_average(average_values, best_values, 'b', 'r', 'b-', 'r-')
